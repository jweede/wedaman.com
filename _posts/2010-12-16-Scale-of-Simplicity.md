---
layout: post
---

I might get some flamage for saying this: I don't like the [Opera](http://www.opera.com/) browser. 

They came out with a new version, so I thought I'd try it. It has a lot of interesting features, and I wanted to see if anything would be of use. I spent a few hours adjusting, fiddling, and trying out some common use cases. It got me to thinking about making great software, and why this didn't really count as great software.

[Joel Spolsky](http://www.joelonsoftware.com/) would say that great software has to have every feature that users want. If it lacks feature X that person Y can't live without, then Y will simply continue to use competing product Z. It's hard to get people to switch if the product doesn't have a "comparable" feature. In response, companies often use a ["fire and motion"](http://www.joelonsoftware.com/articles/fog0000000339.html) strategy of bundling and improving faster than their competition, so their competition can never catch up. Great business strategy.

But I don't think it's the whole story. In order "win", software has to have more features tacked on every year. Termed "feature creep", developers berate it for the tendency to make software less stable. However, there's another more important side effect.

If you started using a product, let's call it Ultimate Chat Client. UCC starts out version 1.0 with a simple feature set because that's all the devs have time for in order to launch early. It connects to AIM and ICQ. These are the most popular at the time, so it's a pretty good start. Anyone can figure out how to use it, because it's so simple and fits the use case. Then the feature requests start rolling in, lots of pie-in-the-sky ideas like "order pizza", "destroy my enemies", or "LISP scripting". Mixed in with those are "more chat protocols" and "unified interface". Embracing "fire and motion", UCC devs implement all of the features. These lead to more feature requests and more features. Finally around version 9.0 UCC is re-termed YUCC and nobody remembers what the acronym was for. Now YUCC can browse the web, regulate your nuclear reactors, and play Stevie Nicks on loop for hours (sorry, no LISP scripting). Great. The devs believe it will become self-aware and refuse to open the pod bay doors by version 13, the veteran users love it and swear by it, and it seems like everyone is happy. 

Well, that is, except one group of people. 

New users can't figure out how to use it, or even what it's for! They hear people talk about it, install it, play with it for a few hours, and then give up. Either that or they get frustrated. They start playing with *other* products, your competition. The other products are simpler, so the user knows how to do things pretty quickly, and generally satisfies what they wanted to do. 

The barrier to entry that the software is supposed to create for its competition is now a barrier to new users. Those prospective new users try other products, grok them right away and stick with those. 

Where did it all go wrong?

It's great to have a lot of features, but can your grandma use it? Probably not without hours of tutoring. My grandma wouldn't be able to use Opera. There's a lot of buttons, and it's hard to explain what all the features do right away. If she had a missive click on one of them, that means instant confusion.

You know what doesn't have a lot of buttons? [Chrome](http://www.google.com/chrome/). That's on purpose. The focus is on the use-case: browsing the web. It dedicates as much space as possible to that. If you want extra features, you use extensions. You can do just about everything that Opera does by extensions, but chances are you won't want to. Chrome is growing faster than Opera. 

Let's call it a "Scale of Simplicity". New users have to be able to do something close to what they want to do--almost immediately--or else they'll try something else. As your product grows, it needs to appear simple to new users, but still have the features that your veteran users will want. Your simplicity needs to scale.